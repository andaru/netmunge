# "show ip ospf neighbor" parser for Cisco IOS
#

def _d(oper_status):
  """Returns the description from the mixed oper status/optional description"""
  if 'up' in oper_status:
    return oper_status.split('up')[1].strip()
  else:
    return oper_status.split('down')[1].strip()



# Begin -- grammar generated by Yapps
import sys, re
from yapps import runtime

class CiscoShowIpOspfNeighborScanner(runtime.Scanner):
    patterns = [
        ("'Neighbor.*Interface'", re.compile('Neighbor.*Interface')),
        ('"-"', re.compile('-')),
        ('\\s+', re.compile('\\s+')),
        ('PRIO', re.compile('[0-9]+')),
        ('STATE', re.compile('[A-ZA-z0-9/\\.]+')),
        ('INTF', re.compile('[A-ZA-z0-9/\\.]+')),
        ('END', re.compile('$')),
        ('ANY', re.compile('.')),
        ('OPER', re.compile('(up|down|admin down).*')),
        ('ADMIN', re.compile('(up|down|admin down)')),
        ('IPV4', re.compile('([0-9]{1,3}\\.){3}[0-9]{1,3}')),
        ('IPV4_2', re.compile('([0-9]{1,3}\\.){3}[0-9]{1,3}')),
        ('TIME3', re.compile('([0-9]{2}:[0-9]{2}:[0-9]{2})')),
    ]
    def __init__(self, str,*args,**kw):
        runtime.Scanner.__init__(self,None,{'\\s+':None,},str,*args,**kw)

class CiscoShowIpOspfNeighbor(runtime.Parser):
    Context = runtime.Context
    def neighbor(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'neighbor', [])
        IPV4 = self._scan('IPV4', context=_context)
        PRIO = self._scan('PRIO', context=_context)
        STATE = self._scan('STATE', context=_context)
        if self._peek('"-"', 'TIME3', context=_context) == '"-"':
            self._scan('"-"', context=_context)
        TIME3 = self._scan('TIME3', context=_context)
        IPV4_2 = self._scan('IPV4_2', context=_context)
        INTF = self._scan('INTF', context=_context)
        return (('ospf_neighbor', IPV4, PRIO, STATE, TIME3, INTF))

    def parse(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'parse', [])
        while self._peek("'Neighbor.*Interface'", 'ANY', context=_context) == 'ANY':
            ANY = self._scan('ANY', context=_context)
        self._scan("'Neighbor.*Interface'", context=_context)
        neigh = set()
        while self._peek('END', 'IPV4', context=_context) == 'IPV4':
            neighbor = self.neighbor(_context)
            neigh.add(neighbor)
        END = self._scan('END', context=_context)
        return neigh


def parse(rule, text):
    P = CiscoShowIpOspfNeighbor(CiscoShowIpOspfNeighborScanner(text))
    return runtime.wrap_error_reporter(P, rule)

if __name__ == '__main__':
    from sys import argv, stdin
    if len(argv) >= 2:
        if len(argv) >= 3:
            f = open(argv[2],'r')
        else:
            f = stdin
        print parse(argv[1], f.read())
    else: print >>sys.stderr, 'Args:  <rule> [<filename>]'
# End -- grammar generated by Yapps
